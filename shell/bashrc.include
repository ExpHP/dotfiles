# vim: ft=sh

# To be source'd in .bashrc

# Wrap in a function so that `local` can be used.
# Awkwardly long name to avoid collision.
doTheSpecialPromptyThing() {
  local none='\[\033[00m\]'
  local bold='\[\033[01m\]'
  local red='\[\033[01;31m\]'
  local green='\[\033[01;32m\]'
  local yellow='\[\033[01;33m\]'
  local blue='\[\033[01;34m\]'
  local purple='\[\033[01;35m\]'
  local cyan='\[\033[01;36m\]'
  local white='\[\033[01;37m\]'

  local lbrace="$white["
  local rbrace="$white]"
  local midbrace="$blue@"
  if ! [[ -z "$NOLIMIT_JUST_IN_TIME" ]]; then
    local lbrace="$red[["
    local rbrace="$red]]"
    local midbrace="$red⚡"
  fi
  local gitgud=
  if which git >/dev/null; then
     gitgud=1
  fi



  # == STATIC REGION ==
  # no command substitutions may be used before the error indicator,
  # to ensure that the value of $? is preserved.
  PS1=""
  PS1+="$lbrace "
  if [[ "$HOSTNAME" == lampam-ThinkPad-T430 ]]; then
    # Username & time
    PS1+="$blue\\u"
    PS1+="$bracecolor $midbrace "
    PS1+="$yellow\t"
  else
    # Username & host
    PS1+="$blue\\u@\\h"
  fi
  PS1+=" $rbrace "

  # == ERROR INDICATOR ==
  PS1+="\$(if [[ \$? != 0 ]];"
  PS1+="then echo \"($red!!!$white) \"; "
  PS1+="fi)"

  # == DYNAMIC REGION ==
  # Git branch
  if which git >/dev/null; then
    PS1+="\$(

      __PS1_GIT_BRANCH=\$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
      if [[ \$__PS1_GIT_BRANCH ]]; then
        __PS1_GIT_BARE=\$(git worktree list --porcelain | grep '^bare$')

        if [[ \$__PS1_GIT_BARE ]]; then
          __PS1_GIT_DIRTY=
          __PS1_GIT_UNTRACKED=0
          __PS1_GIT_ADDITIONS=0
          __PS1_GIT_DELETIONS=0
        else
          __PS1_GIT_DIRTY=\$(git status --porcelain 2>/dev/null)
          __PS1_GIT_UNTRACKED=\$(git ls-files --others --exclude-standard | wc -l 2>/dev/null)
          __PS1_GIT_ADDITIONS=\$(git diff --shortstat | awk '{ print \$4 }' 2>/dev/null)
          __PS1_GIT_DELETIONS=\$(git diff --shortstat | awk '{ print \$6 }' 2>/dev/null)
        fi
        echo -n \"$none(\"

        if [[ \$__PS1_GIT_BARE ]]; then
          echo -n \"${cyan}bare\"
        elif [[ \$__PS1_GIT_DIRTY ]]; then
          echo -n \"$yellow\$__PS1_GIT_BRANCH\"
        else
          echo -n \"$green\$__PS1_GIT_BRANCH\"
        fi

        echo -n \"$none\"
        if   [[ \$__PS1_GIT_UNTRACKED -gt 0 ]]; then
          echo -n \" •\$__PS1_GIT_UNTRACKED\"
        fi

        if [[ \$__PS1_GIT_DELETIONS -gt 0 ]]; then
          echo -n \" ${red}-\$__PS1_GIT_DELETIONS\"
        fi
        if [[ \$__PS1_GIT_ADDITIONS -gt 0 ]]; then
          echo -n \" $green+\$__PS1_GIT_ADDITIONS\"
        fi
        echo -n \"$none) \"
      fi
  )"
  fi

  # Current directory
  PS1+="$green\w$none"

  # Prompt on newline
  PS1+="\n"
  PS1+="${white}\\\$${none} "
}

doTheSpecialPromptyThing

# cleanup
unset -f doTheSpecialPromptyThing

shopt -s globstar
shopt -s extglob
#shopt -s failglob  # Wrecks with some tab-completions...

# so readline has a vim mode
set -o vi

#------------------------------------------------------
# replicate zsh's inc_append_history. Or at least, try to.

export HISTCONTROL=ignoredups:erasedups
export HISTSIZE=100000
export HISTFILESIZE=100000
shopt -s histappend

# Add to the history after each command finishes
export PROMPT_COMMAND="history -a; $PROMPT_COMMAND"
